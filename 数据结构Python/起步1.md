# 起步

[TOC]

## 1 - 计算机问题的求解

​	用计算机解决问题的过程分为两个阶段：程序开发者针对要解决的问题开发出相应的程序，使用者运行程序处理问题的具体实例，完成具体的计算。

### 1.1 程序开发过程

程序开发的各个阶段：

- 分析阶段 - 弄清问题。

- 设计阶段 - 设计解决问题计算过程的模型，这种模型包括两个方面：表示计算中处理的数据；求解问题的计算方法（算法）。

- 编码阶段 - 用某种适当的编程语言实现这个模型，做出一个可能由计算机执行的实际计算模型，即程序。

- 检查测试阶段 - 找出代码中的各种错误，如语法呵呵类型错误，通过人或计算机的检查可以发现这些错误。

- 测试/调试阶段 - 程序运行不出错，不一定就是想要的程序，还需要通过尝试性的运行确定其功能是否满足需要。

- 如图：

  ![](C:/Users/lsmil/Documents/Python%20Knowledge/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python/images/1-1.png)

- 例子 - 求出任意一个非负实数的平方根（算术平方根）

  1. 定义：一般地说,若*一个*非负数y的平方等于x,即y²=x ,则这个数y叫做x的算术平方根。

  2. 问题修改：对任意非负实数x，设法找到非负实数y，是的|y*y-x|<e，e是允许误差。

  3. 牛顿迭代法求平方根：

     - 对给定正实数x和允许误差e，令变量y取任意正实数值，如令y=x；
     - 如果y*y与x足够接近，即|y\*y-x|<e，计算结束并把y作为结果；
     - 取z=（y+x/y）/2;
     - 将z作为y的新值，回到步骤1。

  4. 二分法求平方根：

     - 在一个区间中，每次拿中间数的平方来试验，如果大了，就再试左区间的中间数；
     - 如果小了，就再拿右区间的中间数来试。
     - 比如求sqrt(16)的结果，你先试（0+16）/2=8，88=64，64比16大，然后就向左移，试（0+8）/2=4，44=16刚好，得到了正确的结果sqrt(16)=4。

  5. 代码实现

     ```python
     """
     用牛顿迭代法的思想去求一个数的平方根
     1、对x的平方根的值一个猜想y。
     2、通过执行一个简单的操作去得到一个更好的猜测：只需要求出y和x/y的平均值（它更接近实际的平方根值）。
     """
     import time
     
     
     def sqrt1(x):
         y = 1.0
         while abs(y * y - x) > 1e-10:         #1e-6是精度
             y = (y + x / y) / 2
         return y
     
     
     """
     用二分法求平方根
     在一个区间中，每次拿中间数的平方来试验，如果大了，就再试左区间的中间数；
     如果小了，就再拿右区间的中间数来试。
     比如求sqrt(16)的结果，你先试（0+16）/2=8，8*8=64，64比16大，然后就向左移，试（0+8）/2=4，4*4=16刚好，得到了正确的结果sqrt(16)=4。
     
     """
     def sqrt2(x):
         low = 0.0
         high = x
         middle = (low + high) / 2
         while abs(middle ** 2 - x) > 1e-10:
             if middle ** 2 > x:
                 high = middle
                 middle = (low + high) / 2
                 #print('high = %f' % high)
             elif middle ** 2 < x:
                 low = middle
                 middle = (low + high) / 2
                 #print('low = %f' % low)
         return middle
     
     
     
     
     def main():
         count = 1
         while count < 5:
             x = float(input("请输入一个数："))
             #方法一用时
             start1 = time.time()
             y1 = sqrt1(x)
             end1 = time.time()
             print("sqrt1求出的%f的平方根是%.10f，用时%f" % (x, y1, end1 - start1))
     
             #方法二用时
             start2 = time.time()
             y2 = sqrt2(x)
             end2 = time.time()
             print("sqrt1求出的%f的平方根是%.10f，用时%f" % (x, y2, end2 - start2))
             count += 1
         else:
             print('over')
     
     if __name__ == '__main__':
         main()
     
     ```

### 1.2 算法的性质

- 有穷性：一个算法的描述应该由有限多条指定或语句构成；
- 可行性：算法中指令的含义严格且简单明确，所描述的操作过程可以完全机械地运行；
- 确定性：作用域所求解问题的给定输入，根据算法的描述将产生出唯一的确定的一个动作序列；
- 终止性：对于问题的任何实例，算法产生的动作序列都是有穷的；
- 输入/输出：有明确的输入和输出。

### 1.3 算法的描述方法

- 自然语言描述
- 在自然语言描述中结合一些数学记法或公式的描述形式
- 采用严格定义的形式化方法
- 用某种编程语言描述算法过程
- 伪代码形式描述

### 1.4 算法设计与分析

算法的设计模式：

- 枚举法。根据具体问题枚举出各种可能，从中选出有用信息或者问题的解，这种方法利用计算机的速度优势。
- 贪心法。根据问题的信息尽可能做出部分解，并基于部分解逐步扩充得到完整的解。但在解决复杂问题时，这种做法未必得到最好的解。
- 分治法。把复杂问题分解为相对简单的子问题，分别求解，最后通过合起子问题的解的方法得到原问题的解。
- 回溯法。专指通过探索的方式求解。如果问题很复杂，没有清晰的求解路径，就需要分步骤进行，根据实际情况选择一个可能的方向。当后面的求解步骤无法继续时，就需要退回到前面的步骤，另行选择求解路径，这种方法称为回溯。
- 动态规划法。在一些复杂的情况下，问题求解很难直截了当的进行，因此需要在前面步骤中积累信息，在后续步骤中根据已知信息，动态选择已知的最好求解路径。
- 分支限界法。如果在搜索过程中可以得到一些信息，确定某些可能的选择实际上并不真正有用，就可以及早将其删除，以缩小可能的求解空间。

### 1.5 算法的代价以及度量

​	同一个算法能应用于不同的实例，计算的实际代价通常与实例的规模有关。因此，把一个算法的开销定义为问题实例规模的函数。以问题实例的某种规模n为参量，反映出这个算法在处理规模n的问题实例时需要付出的时间（空间）代价。

#### 1.5.1 算法复杂度

​	在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和 f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f( n)是问题规横n的某个函数。

1. ”**大O记法**“：对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，是的对于充分大的n总有f(n)<=c*g(n)，就说函数g是f的一个渐进函数，记为f(n)=O(g(n))。

2. 算法中的描述：假设存在函数g，是的算法A处理规模为n的问题实例所用时间T(n)=O(g(n))，则称O(g(n))为算法A的渐进时间复杂度，简称时间复杂度。

3. 常见时间复杂度函数

   O(1)，O(logn)，O(n)，O(nlogn)，  O(n^2^)， O(n^3^)，  O(2^n^)

   O(1) - 常量复杂度；

   O(logn) - 对数复杂度；

   O(n) - 现行复杂度；

   O(n^2) - 平方复杂度；

   O(2^n) - 指数复杂度。

   ![](.\images\1-2.png)

4. 例子 - 斐波那契数列

   - 数学定义：

     F(0)=F(1)=1

     F(n)=F(N-1)+F(n-2), n>1

   - 算法描述

     ```Python
     # 求斐波那契数列的第n项
     """
     斐波那契数列的定义：
     F0=F1=1，Fn=Fn-1+Fn-2,n>1
     """
     
     import time
     
     # 方法一
     def fib_way1(n):
         if n<2:
             return 1
         else:
             return fib_way1(n-1) + fib_way1(n-2)
     # 方法一优化
     def fib_way11(num, result={}):
         if num in (1, 2):
             return 1
         try:
             return result[num]
         except KeyError:
             result[num] = fib_way11(num - 1) + fib_way11(num - 2)
             return result[num]
         
     # 方法二
     def fib_way2(n):
         f1 = f2 = 1
         for k in range(1, n):
             f1, f2 = f2, f1 + f2
         return f2
     
     #方法三-生成器
     def fib_way3():
         a, b = 0, 1
         while True:
             yield b
             a, b = b, a + b
     
     
     def main():
         start = time.time()
         fib_way1(30)
         end = time.time()
         print('fib_way1用时%f' % (end - start))
     
         start = time.time()
         fib_way2(30)
         end = time.time()
         print('fib_way2用时%f' % (end - start))
     
         fib = fib_way3()
         start = time.time()
         a_List = [next(fib) for i in range(30)]
         print(a_List)
         end = time.time()
         print('fib_way3用时%f' % (end - start))
     
     if __name__ == '__main__':
         main()
     
     ```

5. 算法的时间复杂度的计算方法（**程序最基本的语句运行的次数的函数**）

   - 基本操作，时间复杂度为O(1)。如果是函数调用，应该将其时间复杂度代入，参与整体时间复杂度的计算。

   - 加法规则（**顺序结构**）。如果算法（算法片段）是两个部分（多个部分）顺序复合，其复杂性是这两个部分（或多部分）的复杂性之和。：

     **T(n)=T~1~(n)+T~2~(n)=O(T~1~(n))+O(T~2~(n))=O(max(T~1~(n),T~2~(n)))**

   - 乘法规则（**循环结构**）。如果算法（算法片段）是一个循环，循环体将执行T~1~(n)次，每次执行需要T~2~(n)时间，那么：

     **T(n)=T~1~(n)xT~2~(n)=O(T~1~(n))xO(T~2~(n))=O(T~1~(n)xT~2~(n))**

   - 取最大规则（**分支结构**）。如果算法（算法片段）是条件分支，两个分支的时间复杂度分别为T~1~(n)和T~2~(n)，则：

     **T(n)=O(max(T~1~(n),T~2~(n)))**

6. 计算

   - 基础

     ```Python
     for i in range(n):  # 执行n次
         for j in range(n):  # 执行n次
             x = 0.0  # 执行1次
             for k in range(n):  # 执行n次
                 x = x + m1[i][k] * m2[k][j]  # 执行1次
             m[i][j] = x  # 执行1次
     
     ```

     ```
     分析：T(n)=O(n)xO(n)x(O(1)+O(n)xO(1)+O(1))=O(n)xO(n)xO(n)=O(nxnxn)=O(n3)
     
     时间复杂度为：O(n3)
     
     ```

     

   - 进阶1

     ```Python
     def func(n):
         i  = 2
         while i < n:
                 i = i * 2
                 print(i)
     ```

     ```
     分析：假设循环次数为t，则循环条件满足2t<n，所以log2t<logn，所以t<logn/log2，即t<log2n，所以时间复杂度为logn
     ```

     

   - 进阶2 - **递归算法的时间复杂度**[转自](https://blog.csdn.net/xiaoxian8023/article/details/8134260)

     **方法一：代换法**

     猜答案，不需要完全猜出来，不需要知道常熟系数的准确值，而只需要猜出它的形式，比如猜一个递归式的时间复杂度大概是O(n2)，即它的运行时间应该是一个常熟乘以n2，可能还会有一些低阶项。 

     **方法二：递归树法**

     递归树法主要是通过递归树将递归式展开来找到答案，然后再用代换法证明它，因为递归树法是不严谨的。

     1. T(n) = T(n/2) + n^2^ , 用递归树法将该递归式展开 

     ![](.\images\1-3.png)

     像这样将递归树展开并延伸下去，最终到叶子节点就只剩下T(1)，那么该递归树的高度就是logn，因为从顶点n出发，到n/2,到n/4,……最后到1，那么从n到1的折半次数是logn，即高度是logn（应该是一个常数乘以logn，不过没多大关系）。而最下面叶子节点的数目是n，因为从第一层往下，节点数变化为1,2,4,8……，如果树的高度是h，那么就会有2h个叶节点，而高度是logn，那么2logn=n。那么，整体所做的工作加起来就是T(n)了

     T(n) = [1+1/2+1/4+……]n2 = 2n2,于是可知时间复杂度为T(n) = O(n2)。

     2. 用递归树法求T(n) = T(n/4)+T(n/2)+n2 ,下面用递归树的方法将该递归式展开 

        ![](.\images\1-4.jpg)

        最后，求叶子节点的数目有点麻烦，因为分支的递归速度是不一样的，左边降低到n/16的时候，右边才降低到n/4，左边子树的高度将会比右边子树的高度要小。可以看到叶子节点的数目必然小于n，因为最开始的问题大小是n，然后递归成一个n/4和n/2的两个子问题，直到最后递归到1停止，而n/4+n/2  < n , 所以最后叶子节点的数目不会超过n，将每层求和就得到T(n)，经过观察发现一个等比数列，于是数学归纳法开始派上用场

        T(n) = (1+5/16+25/256+……)n2≤2n2 =O(n2)   于是得到该递归式时间复杂度为O(n2)，因为是猜出来的等比数列，于是需要用数学归纳法证明之，就又变成方法一中代换法求证了。

#### 1.5.2 把一系列数插入一个表

```Python
"""
把一系列数存入一个表
"""
import time


def way1(*args):            #python中的不定长参数把传进来的参数放在一个元祖里
    a_List = []
    tuple_temp = iter(args)
    for i in range(len(args)):
        a_List.insert(0, next(tuple_temp))
    return a_List

def way2(*args):            #python中的不定长参数把传进来的参数放在一个元祖里
    a_List = []
    tuple_temp = iter(args)
    for i in range(len(args)):
        a_List.append(next(tuple_temp))
    return a_List

def main():
    start = time.time()
    way1_result = way1(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
    end = time.time()
    time1 = end - start

    start = time.time()
    way2_result = way2(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
    end = time.time()
    time2 = end - start

    print('way1结果：', way1_result)
    print('way1用时：', time1)
    print('way2结果：', way2_result)
    print('way2用时：', time2)


if __name__ == '__main__':
    main()
```



## 2 - 数据结构

​	数据结构研究数据之间的关联和组合形式。

![](.\images\1-6.png)

### 2.1 几个概念

- 数据：计算机（程序）能够处理的符号形式的总和，或者说是经过了编码的信息。

- 数据项：一个数据元素由若干数据项组成。

- 数据元素：组成数据对象的基本单位。

- 数据对象：性质相同的数据元素的集合。类似于列表。

- 图示：

  ![](.\images\1-5.png)

### 2.2 抽象定义与重要类别

​	从逻辑上看，一个数据结构包含一集数据元素，是一个有穷集，在这些元素之间有着某些特定的逻辑关系。这样看来，一个具体的数据结构就是一个二元组

​                                                       **D=(E,R)**

其中E是数据结构D的元素集合，是某个数据集合的一个有穷子集，而R∈EXE是D的元素之间的某种关系。典型的数据结构有：

- 集合结构：其数据元素之间没有明确的关系，即关系R是空集。
- 序列结构：其元素之间有一种明确的先后关系（顺序关系）。
- 层次结构：其数据元素属于一些不同的层次，一个上层元素可以关联着一个或者多个下层元素，关系R形成一种明确的层次性。层次结构有许多简单或者复杂的类别。
- 树形结构：层次结构中最简单的一种树形关系，特点是在一个树形结构中只有一个最上层数据元素，称为根，其余元素都是根的直接或间接关联的下层元素。
- 图结构：元素之间可以有任意复杂的相互关系。

### 2.3 计算机内存对象表示

#### 2.3.1 内存单元和地址

​	计算中（程序中）直接使用的数据保存在计算机的内存储器（内存）。内存是CPU可以直接访问的数据存储设备。与之相对应的是外存储器，外存，如磁盘、光盘。保存在外存里的数据必须先装入内存，然后CPU才能使用它们。

​	内存的基本结构是现行排列的一批存储单元。每个单元大小相同，可以保存一个单位大小的数据。在目前的计算机中，一个单元可以保存一个字节（8位二进制代码）的数据。

​	内存单元具有唯一编号，称为单元地址，简称地址。单元地址从0开始连续排列。

​	在程序执行中，对内存单元的访问（存取其中数据）都通过单元地址进行，因此要访问一个单元，必须先知道地址。在目前常见的64位计算机中，一次可以存取8个字节的数据，也就是说一次操作访问8个单元的内容。

#### 2.3.2 对象存储和管理

​	在程序运行中，可能需要构造、使用、处理各种各样的对象，它们都将在计算机的线性结构的内存里安排位置。为了表示程序里的一个对象，需要根据情况，在空闲的内存中确定一块或几块区域，把对象的数据存入其中。在Python程序运行中，建立对象时需要安排存储，还有许多与对象存储和使用有关的管理工作。解释器的一个专门子系统（称为存储管理系统）负责这些工作。这一工作自动进行，编写程序的人不必关心。当一个对象不再有用时，存储管理系统也会设法回收期占用的存储，以便将来用于存储其他对象。

​	一些程序在运行中将不断建立一些对象并使用它们。建立的每一个对象都有一个确实的唯一的标识，用于识别和使用这个对象。在一个对象的存储期间，其辨识保持不变，这是一个基本原则。