# 线性表



## 1 - 表的抽象数据类型

```reStructuredText
ADT List:                    # 表抽象数据类型
    List(self)               # 表构造操作，创建一个新表
    is_empty(self)           # 判断self是否为空表
    len(self)                # 获得self的长度
    prepend(self,elem)       # 将元素elem加入表中作为第一个元素
    append(self,elem)        # 将元素elem加入表中作为最后一个元素
    insert(self,elem,i)      #将elem加入表中作为第i个元素，其他元素的顺序不变
    del_first(self)          # 删除表中首元素
    del_last(self)           # 删除表中尾元素
    del(self,i)              # 删除表中第i个元素
    search(self,elem)        # 查找元素elem在表中出现的位置，不出现返回-1
    forall(self,op)          # 对表中的每个元素执行操作op
```



## 2 - 实现方式

- 顺序表
- 链表

### 2.1 顺序表实现

​	基本实现方式：表中元素顺序放在一片足够大的连续存储空间，首元素（第一个元素）存入存储区的开始位置，其余元素一次存放。元素之间的逻辑关系通过元素在存储区里的物理位置表示。

#### 2.1.1 基本实现方式

- 表中元素类型相同

  1. 这样存储每个表元素所需的存储量相同，可以在表里等距安排同样大小的存储位置。

  2. 假设有一个顺序表对象，其元素存储在一片元素存储区，该存储区的起始位置（内存地址）已知为l~0~。假设元素编号从0开始，元素e~0~的位置为Loc(e~0~)=l~0~，如果表中一个元素所需的存储单元数为c=size，则e~i~的地址计算公式：

     ​						Loc(e~i~)=Loc(e~0~)+cxi

  3. 图示：

     ![](.\images\3-1.png)

- 表中元素类型不同

  1. 将实际数据另行存储，在顺序表里各单元位置保存对相应元素的应用信息。由于每个引用所需的存储量相同，可以通过上面的公式计算出引用的存储位置，就能得到实际元素的数据了。

  2. 图示：

     ![](.\images\3-2.png)

  

### 2.2 相关操作实现

​	建立可变的顺序表。在一个顺序表的元素存储区中，一般情况是保存着一些元素，还存在一些可以存放元素的空位。在这种情况下需要约定元素的存放方式，通常把已有元素连续存放在存储区的前一段，空位留在后面。为了保证正确的操作，需要记录元素存储区的大小和当前的元素个数。

![](.\images\3-3.png)

```Python
#顺序表类
class seq_list(object):
    #顺序表的最大容量、元素个个数、存放数据的数组
    def __init__(self, max = 10):
        self.max = max
        self.num = 0
        self.data = [None] * self.max
        #self.data = [''] * self.max

    #输出线性表中的数据
    def __str__(self):
        return " ".join((str(self.max), str(self.num), str(self.data)))

    #判断空
    def is_empty(self):
        return self.num is 0

    #判断是否满了
    def is_full(self):
        return self.num is self.max

    #获取线性表的长度，既元素 个数
    def count(self):
        return self.num


    #在线性表的末尾增加一个元素
    def append(self, element):
        #先判断表是否满了
        if self.num == self.max:
            print("表已经满了！操作失败！")
            return
        else:
            self.data[self.num] = element
            self.num += 1

    #在线性表下表为loc的位置添加元素，而不是插在第几个
    def insert(self, loc, value):
        #判断表是否满了
        if self.is_full():
            print('表已经满了！')
            return
        elif loc < 0:
            raise IndexError('下标错误')
        else:
           for i in range(self.num, loc, -1):
               self.data[i] = self.data[i-1]
           self.data[loc] = value
           self.num += 1

    #查找
    #查找所有值为value的元素并返回下标，把下标放在列表里
    def search(self, value):
        for i in range(0, self.num):
            if self.data[i] == value:
                yield i
    #查找第一个元素值为value的值的下标并返回
    def search(self, value):
        for i in range(0, self.num):
            if self.data[i] == value:
                return i


    #删除
    #删除下表为loc的元素
    def delete_l(self, loc):
        if loc < 0 or loc > self.num - 1:
            raise IndexError
        else:
            for i in range(loc, self.num):
                self.data[i] = self.data[i+1]
            self.num -= 1

    #删除所有值为value的元素
    def delete_v(self, value):
        j = 0 #记录删除的个数
        #先看值是否存在
        for i in range(self.num):
            if self.data[i] == value:
                self.delete_l(i)
                j += 1
        if j == 0:
            return '不存在该'


seq = seq_list()
#print(seq)
#print(seq.is_empty())
#print(seq.is_full())
for i in range(5):     #加入元素
    seq.append(i)
#在c语言的顺序表中一个表中 只能放类型相同的元素，在这可以放各种不同的元素
#seq.append([x * x for x in range(3)])
#seq.append('felix')
# print(seq.count())     #统计个数
seq.insert(2, 4)
for j in range(seq.num):  #输出目前的元素
    print(seq.data[j])
# print(seq.count())
# seq.delete_l(2)
# for j in range(seq.num):
#     print(seq.data[j])
# print(seq.count())
#print(type(seq.data[2]))
#print(seq.search('two'))
#print(list(seq.search(4)))


```

### 2.3 顺序表及其操作的性质

​	定位加入和删除操作的时间复杂度。

假设给定的顺序表里有n个元素，在其中下表为i的位置加入一项新数据，需要移动n-i个元素；删除下表为i的数据项需要移动n-i-1个元素。再假设在位置i加入和删除元素的概率分别为p~i~和p~i~^‘^，则加入操作中平均元素移动次数是：∑~i=0~^n^ (n-i)*p~i~，删除操作的平均移动次数是

∑~i=0~^n-1^ (n-i-1)*p~i~^‘^ 。这两个操作的平均时间复杂度是O(n)。最坏情况也是O(n)。

### 2.4 顺序表小结

- 优点：随机存取元素（O(1)时间完成）；元素在表里存储紧凑，除表元素存储区之外只需要O(1)空间存放少量辅助信息。
- 缺点：需要连续的存储区存放表中元素，如果表很大，就需要很大片的连续内存空间；一旦确实了存储块的大小，可容纳元素个数并不随着插入/删除操作的进行而变化；如果很大的存储区只存了少量的数据项，就会有大量空闲单元，造成内存浪费；在执行加入或删除操作时，通常需要移动许多元素，效率低；建立表时需要考虑元素存储区的大小，可是实际中很难事先估计。

### 2.5 顺序表的结构

#### 2.5.1 两种基本实现方式

- 一体式结构

  ![](C:/Users/lsmil/Documents/Python%20Knowledge/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python/images/3-4.png)

  ​	存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，几部分数据的整体形成一个完整的表对象。这种实现方式比较紧凑，有关信息几种在一起，整体性强，易于管理。缺点是创建后元素存储区就固定了。

- 分离式结构

  ![](C:/Users/lsmil/Documents/Python%20Knowledge/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Python/images/3-5.png)

  ​	表对象里只保存与整个表有关的信息（容量和元素个数），实际元素存放在另一个独立的元素存储区，通过链接与基本表对象关联。这样表对象的大小统一，但不同表对象可以关联不同大小的元素存储区。

#### 2.5.2 替换元素存储区

​	分离式结构的优点是，标识不变的情况下，为表对象换一块元素存储区。也就是说，表还是原来的表，内容没变，只是容量变了。如果用一体式结构实现顺序表，那么当表里面的元素满了以后，如果再插入数据就会出错，这时，分离式结构就派上用场了。这时可以在不改变对象的情况下换一块更大的存储区，过程：

- 另外申请一块更大的元素存储区；
- 把表中已有元素复制到新的存储区；
- 用新的元素存储区替换原来的元素存储区；
- 实际加入新元素。

#### 2.5.3 后端插入和存储区扩充

​	当不确定表中的元素数量时，可用动态存储技术。这样，每当表满时就换一块存储区，虽然在后端插入元素的时间复杂度是O(1)，但是，当需要换更大的存储区时，要复制表中的元素，整个复制需要O(m)时间（m是当时的元素个数）。可能的解决方法是，每次换元素存储区时增加n个空位，这样，复制次数大约是1/20xn^2^ 。如果每次增加这时一次插入操作的平均代价是O(n)。如果每次容量加倍，元素复制的次数是O(n)，这时插入操作的平均时间复杂度是O(1)。**Python标准类型的list就利用了这种分离式存储技术。**



### 2.2 链接表

​	实现线性表的另一种方式就是链接结构。基本思想：

- 把表中元素分别存储在一批独立的存储快里。
- 保证从组成表结构中的任一结点可找到与其相关的下一结点。
- 在前一结点里用链接的方式显示地记录与下一结点之间的关联。

#### 2.2.1 单链表

1. 概念：单向链接表（单链表）的结点是一个二元组，其表元素域elem保存着作为表元素的数据项，链接域next里保存着同一个表里的下一个结点的标识。

   ![](.\images\2-1.png)

2. 特点：

   - 从引用表中首结点的变量（p）可以找到这个表的首结点；
   - 从表中任意一结点可以找到下一个结点，这样，从p就能找到表中所有结点。

3. 小结：

   - 为了掌握一个表，只要用一个变量保存着这个表的首结点的引用。这个变量称为**表头变量或表头指针**；
   - 一个单链表由一些具体的表结点构成；
   - **每个结点是一个对象，有自己的标识，称其为该结点的链接**；
   - 结点之间通过结点链接建立起单向的顺序联系。
   - **表的结束**：给表的最后结点的链接域设置一个不会作为结点对象标识的值，用Python中用**None**表示。

4. 表结点类

   ```Python
   class LNode(object):
   
       def __init__(self, elem, next_=None):
           self.elem = elem
           self.next = next_
   
   # 创建一个结点
   llist1 = LNode(1)
   # p指向这个结点
   p = llist1
   
   # 在结点后添加数据项elem为2,3...10的结点
   for i in range(2, 11):
       # p指向结点llist1，p.next为结点llist1的next域
       p.next = LNode(i)
       # 让p指向当前表的最后一个结点
       p = p.next
   # 再让p回到第一个结点
   p = llist1
   # 如果p的下一个不为空
   while p is not None:
       print(p.elem)
       # p往后移动一个结点位置
       p = p.next
   
   '''
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   '''
   ```

5. 单链表类的定义和相关操作

   基于结点类LNode定义一个单链表对象的类，在这个表对象里只有一个引用链接结点的_head域，初始化为None表示建立的是空表。

   - 相关操作

     - 创建空链表

       把表头变量_head设为None

       ```Python
       head = None
       ```

       

     - 删除链表

       丢弃这个链表里的所有结点，把表头变量_head设为None

       ```Python
       head = None
       ```

       

     - 判断链表是否为空

       将表头变量与空链接比较，即检查表头指针是否是None

       ```Python
       return head is None
       ```

       

     - 判断表是否满了

       一般链表是不会满的，除非计算机内存被用完了

     - 插入元素

       头插法、尾插法、定位插入。向单链表中插入元素是不需要移动元素的，只需要将相应的结点链接在链表的相应的位置即可，通过修改链接实现。

       - **头插法** - 向表中插入一个元素作为表的第一个元素。

         1. 创建一个结点，数据域存放需要插入的数据；

         2. 把原来的头结点的指针域（链接域）存入新结点的指针域；

         3. 把头指针指向新添加的结点

         4. 图示：

            ![](./images/2-2.png)

         5. 代码：

            ```Python
            q = LNode(elem)
            q.next = head.next
            head = q
            ```

            

       - **定位插入** - 要想在单链表的一个位置插入新的结点，那么必须知道该位置之前的那个结点。假如已经找到要插入结点的前一个结点的索引pre：

         1. 创建一个结点存入数据；

         2. pre所指结点的链接域的值存入新的结点的链接域，这样就将原来pre所指结点的后面的所有结点链接到新结点后面了；

         3. 修改pre的链接域next的值，值其指向新结点。

         4. 图示：

            ![](./images/2-3.png)

         5. 代码：

            ```Python
            q = LNode(elem)
            q.next = pre.next
            pre.next = q
            ```

            

       - **尾插法**

     - 删除元素

