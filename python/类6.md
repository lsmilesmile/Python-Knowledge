# 类

主要介绍Python中面向对象编程的基本方法和基本思想，包括

- 对象
- 类与对象
- 定义和使用类
- 类的属性和方法
- 类的继承
- 类的方法重载



## 1 - 面向对象简介（OOP）

### 1.1 万物皆对象

​	面向对象就是通过面向对象分析和设计，建立模型（类或对象）并完成最终的程序设计过程。因此在面向对象编程中，编程的主题就是用类或对象构建模型，并使它们之间可以相互通信以解决实际问题。

### 1.2 好处

- 封装 - 将对象的属性和方法封装起来，需要对外展示的，其他对象才能得到或使用它，而不需要对外展示的细节，则隐藏在对象的颞部。
- 继承 - 通过获取父类的属性和方法，再加上自定义的属性和方法成为一个类的子类。
- 多态 - 对于不同的对象，总能有一定的解决办法，并且能得到想要的结果。



## 2 - 类和对象

### 2.1 定义类

语法形式：

**class <类名>(父类名):**

​    **pass**

在Python3.x中，一般定义的类主要继承object类，所以父类名一般是object。我们可以通过dir()看见从object类继承到的属性和方法：

```Python
class Test(object):
    pass
print(dir(Test))

"""
结果
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
"""
```

可以看到这些继承过来的方法

### 2.2 使用类

​	类在定以后必须先实例化才能使用，类的实例化跟函数的调用雷士，只要使用类名加圆括号的形式就可以实例化一个类。

代码示例：

```Python
class Myclass(object):  #定义一个类
    "Myclass."          #该类只有说明信息没有语句

myclass = Myclass()     #实例化一个类
print(myclass.__doc__)  #输出类实例myclass的属性__doc__的值
print(help(myclass))
"""
结果
Myclass.
Help on Myclass in module __main__ object:

class Myclass(builtins.object)
 |  Myclass.
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

None
"""
```

### 2.3 类的属性和方法

#### 2.3.1 类的方法

类中的方法定义和调用与函数定义与调用的方式基本相同，区别有：

- 方法的第一个参数必须是self，而且不能省略，**它代指对象本身**；
- 方法的调用需要实例化类，并且以实例名.方法名形式调用；
- 整体进行一个单位的缩进，表示属于类中的内容。

代码实例：

```Python
class People(object):
    def myname(self):
        return 'my name is felix'
    
    def add_fun(self, x, y):
        return(x+y)
    
people = People()
print(people.myname())
print(people.add_fun(1, 1))
"""
my name is felix
2
"""
```

在类定义中可以定义一个特殊的构造方法，\_\_init\_\_()方法，用于类实例化的初始化，**如果这个方法中有参数，那么在实例化时就必须提供**。

代码示例：

```Python
class Test(object):
    def __init__(self, value1, value2):
        self.x = value1
        self.y = value2
    
    def fun(self):
        return self.x * self.y

test = Test(10, 9)
print(test.fun())
"""
90
"""
```

调用本类方法和全局方法：

```Python
def coord_chng(x, y):
    return (abs(x), abs(y))

class Ant(object):
    
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
        self.disp_point()
        
    def move(self, x, y):
        x, y = coord_chng(x, y)
        self.edit_point(x, y)
        self.disp_point()
    
    def edit_point(self, x, y):
        self.x += x
        self.y += y
        
    def disp_point(self):
        print("当前位置：(%d, %d)" % (self.x, self.y))
        

ant = Ant()
ant.move(2, 4)
ant.move(-9, 6)
"""
当前位置：(0, 0)
当前位置：(2, 4)
当前位置：(11, 10)
"""
```

#### 2.3.2 类的属性

Python中的类的属性有两类：

- 实例属性
- 类属性

实例属性即同一个类的不同实例，其值是不相关的，也不会互相影响的，定义时使用“self.属性名”，调用时也使用它；类属性则是同一个类的所有实例所共有的，直接在类体中独立定义，引用时要使用“类名.类变量名“的形式来引用。

代码示例：

```Python
class Test(object):
    name = 'Felix'
    
    def __init__(self, value = 'hello'):
        self.name = value
        
    def func1(self):
        return Test.name, self.name
    
    def chg_cname(self, ctemp):
        Test.name = ctemp
        
    def chg_sname(self, stemp):
        self.name = stemp
        
test = Test()
print('修改前的类属性和实例属性：', test.func1())
test.chg_cname('FFF')
test.chg_sname('HHH')
print('修改后的类属性和实例属性：', test.func1()[0], test.func1()[1])

"""
修改前的类属性和实例属性： ('Felix', 'hello')
修改后的类属性和实例属性： FFF HHH
"""
```

实例：

```Python
#car类
class Car(object):
    def __init__(self, brand, color, price):
        self.brand = brand
        self.color = color
        self.price = price

    def func(self):
        print('我的功能是作为交通工具')

    def __str__(self):
        return '%s, %s, %d' % (self.brand, self.color, self.price)

    def __del__(self):
        print('我是做清理工作的')


#book类
class Book(object):
    def __init__(self, subject, size, price):
        self.subject = subject
        self.size = size
        self.price = price


    def func(self):
        print('这本书的学科是%s, 价格是%d' % (self.subject, self.price))

    def __del__(self):
        print('我是做清理工作的')

#电脑类
class Computer(object):
    def __init__(self, color, brand, price):
        self.__color = color
        self.__brand = brand
        self.__price = price

    def func(self):
        return '我很喜欢%s的电脑，%s也不错，才%d元' % (self.__brand, self.__color, self.__price)

    def __str__(self):
        return '%s,%s,%d' % (self.__color, self.__brand, self.__price)

    def get_chara(self):
        return (self.__color, self.__brand, self.__price)

    def set_chara(self,value1, value2, value3):
        self.__color = value1
        self.__brand = value2
        self.__price = value3

    def __del__(self):
        print('我是做清理工作的')

#类外部的方法
def add_func(self):
    print('我是要被添加给对象的方法')


car1 = Car('audi', 'black', 3000000) #实例化对象
print(car1)                          #输出对象的属性信息
car1.func()                          #调用对象的方法
car1.length = 3                      #为对象添加属性
print(car1.length)                   #输出添加的属性

#给对象添加方法
import types

car2 = Car('jaguar', 'red', 560000)
car2.add_func = types.MethodType(add_func, car2)  #绑定方法到对象
car2.add_func()


computer1 = Computer('white', 'lenovo', 4555)     #实例化一个对象
print(computer1.func())                           #调用对象的方法
print(computer1)
#print(computer1.__color)                         #直接访问私有属性报错
print(computer1.get_chara())
computer1.set_chara('yellow', 'benchi', 869869)
print(computer1)
#del computer1
#print(computer1)

"""
audi, black, 3000000
我的功能是作为交通工具
3
我是要被添加给对象的方法
我很喜欢lenovo的电脑，white也不错，才4555元
white,lenovo,4555
('white', 'lenovo', 4555)
yellow,benchi,869869
我是做清理工作的
我是做清理工作的
我是做清理工作的
"""
```



#### 2.3.3 类成员方法与静态方法

类的属性有类属性和实例属性之分，类的方法也有不同的种类，有：

- 实例方法
- 类方法
- 静态方法

静态方法定义时应该使用装饰器@staticmethod进行修饰，没有默认参数。类方法定义时应使用装饰器@classmethod进行修饰，必须有默认参数“cls”，代表本类。它们的调用方式可以直接由类名进行调用，调用前也可以不实例化类，当然也可以用该类的任何一个实例来进行调用。

代码示例：

```Python
class Test(object):
     @staticmethod                  #静态方法装饰器
     def static_test():
         print('this is a static method')
         
     @classmethod                   #类方法装饰器
     def class_test(cls):
         print('this is a class method')
#未实例化
Test.static_test()
Test.class_test()
#实例化
test = Test()
test.static_test()
test.class_test()
"""
this is a static method
this is a class method
this is a static method
this is a class method
"""
```

### 2.4 类的继承

#### 2.4.1 单继承

​	子类继承了父类之后，就具有了父类的属性和方法，但是不能继承父类的私有属性和私有方法，子类中还可以重载父类的方法，以实现父类的不同行为和表现或能力。

代码示例：

```Python
#类继承
class Ant(object):
    
    #构造方法
    def __init__(self, x=0, y=0, color='black'):
        self.x = x
        self.y = y
        self.color = color
    
    #模拟爬行
    def crawl(self, x, y):
        self.x = x
        self.y = y
        print('爬行...')
        self.info()
    
    def info(self):
        print('当前位置：(%d, %d)' % (self.x, self.y))
        
    
    def attack(self):
        print('用嘴咬')

#定义FlyAnt类继承自Ant
class FlyAnt(Ant):
    
    #重写攻击方式
    def attack(self):
        print('用屁股')
        
    #定义方法，模拟飞行
    def fly(self, x, y):
        print('飞行...')
        self.x = x
        self.y = y
        self.info()

flyant = FlyAnt(color='red')
flyant.crawl(3, 5)
flyant.fly(10, 14)
flyant.attack()

"""
爬行...
当前位置：(3, 5)
飞行...
当前位置：(10, 14)
用屁股
"""
```

#### 2.4.2 多重继承

​	多重继承的方式是在类定义时的继承父类的括号中，以“,”分隔开要多重继承的父类即可。而多重继承时，继承顺序也是一个很重要的因素，如果继承的多个父类中有相同的方法名，但爱类中使用时未指定父类名，则Python解释器将从左至右搜索。

代码示例：

```Python
#父类1
class PrntA(object):
    
    namea = 'PrinA'
    
    def set_value(self, a):
        self.a = a
    
    def set_namea(self, namea):
        PrntA.namea = namea
        
    def info(self):
        print('PrinA:%s, %s' % (PrntA.namea, self.a))
#父类2
class PrntB(object):
    nameb = 'PrntB'
    
    def set_nameb(self, nameb):
        PrntB.nameb = nameb
    
    def info(self):
        print('PrntB:%s' % (PrntB.nameb,))
#子类1
class Sub(PrntA, PrntB):
    pass
#子类2
class Sub2(PrntB, PrntA):
    pass
#子类3
class Sub3(PrntA, PrntB):
    
    #重写方法
    def info(self):
        PrntA.info(self)
        PrntB.info(self)
        
print('使用第一个子类：')
sub = Sub()
sub.set_value('aaaa')
sub.info()                   #调用PrntA中的info()
sub.set_nameb('BBBB')
sub.info()                   #还是调用PrntA中的info()
print('-'*15)
"""
使用第一个子类：
PrinA:PrinA, aaaa
PrinA:PrinA, aaaa
"""

print('使用第二个子类：')
sub2 = Sub2()
sub2.set_value('aaaa')       #调用只有PrntA中有的方法
sub2.info()                  #调用在父类列表中前面的PrntB中的info()
sub2.set_nameb('BBBB')
sub2.info()                  #还是调用在父类列表中前面的PrntB中的info()
"""
使用第二个子类：
PrntB:PrntB
PrntB:BBBB
"""

print('使用第三个子类：')
sub3 = Sub3()
sub3.set_value('aaaa')
sub3.info()
sub3.set_nameb('BBBB')
sub3.info()
"""
使用第三个子类：
PrinA:PrinA, aaaa
PrntB:PrntB
PrinA:PrinA, aaaa
PrntB:BBBB
"""
#上面的代都是单独执行的，不是一次全部执行的
```

### 2.5 方法重载

​	当子继承父类时，子类如果想要修改父类的行为，则应该使用方法重载来实现，方法重载的基本方法是在子类中定义一个和所继承的父类中需要重载方法同名的一个方法即可。

代码示例：

```Python
class Test1(object):
    
    def  func(self):
        return '我是父类的func'

class Test2(Test1):
    
    def func(self):
        return '我是子类的func，我重写了父类的func'

test1 = Test1()
test2 = Test2()
print(test1.func())
print(test2.func())
"""
我是父类的func
我是子类的func，我重写了父类的func
"""
```



## 3 - 小结

​	本文档主要介绍了类的定义、类的属性和方法、其中类属性包括实例属性和类属性，类方法包括实例方法、类方法和静态方法，还介绍了类的继承，包括多继承和单继承，以及类方法的重载。